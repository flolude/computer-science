\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{color}
\usepackage[a4paper, total={6in, 10in}]{geometry}
\usepackage{amsmath}
\usepackage[document]{ragged2e}
\usepackage[ngerman]{babel}

\definecolor{my_red}{RGB}{216,60,104}
\definecolor{my_green}{RGB}{68,189,77}
\definecolor{my_grey}{RGB}{78,90,107}
\titleformat{\section}{\large\bfseries}{}{0em}{}
\titleformat{\subsection}{\bfseries}{}{0em}{}
\titleformat{\subsubsection}{}{}{2em}{}

\lstdefinestyle{customCStyle}{
  language=C,
  numbers=left,
  stepnumber=1,
  breaklines=true,
  showstringspaces=false,
  keywordstyle=\color{my_red},
  stringstyle=\color{my_green},
  commentstyle=\color{my_grey},
  morecomment=[l][\color{magenta}]
}
\lstset{basicstyle=\ttfamily\small,style=customCStyle}

\begin{document}
\title{Aufgabenblatt 12: Dynamische Datenstrukturen (2)}
\author{Florian Ludewig (Übungsgruppe 2)}
\maketitle
\section{Aufgabe 1 -- Doppelt verkettete Listen}
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>

struct dnode *head, *last;

struct dnode{
  int data;
  struct dnode *next, *prev;
};

struct dnode *mkNode(int val){
  struct dnode *node = NULL;
  if((node = malloc(sizeof (struct dnode))) != NULL) {
    node -> data = val;
    node -> next = node -> prev = NULL;
    return node;
  }
  else return NULL;
}

void printList(void) {
  if (head == NULL) {
    printf("( )");
    return;
  }
  printf("( ");
  struct dnode *tmp = head;
  while(tmp != NULL){
  printf("%d ", tmp -> data);
    tmp = tmp -> next;
  }
  printf(")\n");
}

struct dnode *insert_start(int val) {
  struct dnode *new_node = mkNode(val);
  if (head == NULL) {
    new_node -> next = NULL;
    head = new_node;
    last = head;
  } else {
    new_node -> next = head;
    head -> prev = new_node;
    head = new_node;
  }
  new_node -> prev = NULL;
  return new_node;
}

void remove_element(int val) {
  if (head -> next == NULL) return;
  struct dnode *deleted;
  if (head -> data == val) {
    deleted = head;
    head = head -> next;
    head -> prev = NULL;
  } else {
    struct dnode *temp = head;
    while(temp -> data != val && temp -> next != NULL) {
      temp = temp -> next;
    }
    if (temp == NULL) return;
    deleted = temp;
    (temp -> prev) -> next = temp -> next;
    if (temp -> next != NULL) {
      temp -> next -> prev = temp -> prev;
    }
  }
  if (deleted) free(deleted);
}

int main(void) {
  int remove, primes[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };
  for (int i = sizeof(primes) / sizeof(int) - 1; i >= 0; i--) {
    insert_start(primes[i]);
  }
  printf("Zahl eingeben: ");
  scanf("%d", &remove);
  remove_element(remove);
  printList();
  return 1;
}
\end{lstlisting}
\newpage
\section{Aufgabe 2 -- Binärbäume}
\begin{lstlisting}
#include<stdio.h>
#include <stdlib.h>

struct node {
  struct node *left;
  struct node *right;
  int data;
};

struct node *mkNode(int d, struct node *l, struct node *r) {
  struct node *n = NULL;
  if((n = malloc(sizeof (struct node))) != NULL){
    n->data = d; n->left = l; n->right = r; return n;}
    else { return NULL;}
  }

struct node *mkLeaf(int d) {
  return mkNode(d, NULL, NULL);
}

void print_inorder(struct node *n) {
  if(n == NULL) return;
  print_inorder(n->left);
  printf("%c\n", n->data);
  print_inorder(n->right);
}

int count_occurrences(struct node *n, char c) {
  if (n == NULL) return 0;
  int match = (n -> data == c);
  int left_occurrences = count_occurrences(n -> left, c);
  int right_occurrences = count_occurrences(n -> right, c);
  return match + left_occurrences + right_occurrences;
}

int main(void) {
  struct node *tree = mkNode(' ', mkNode('n', mkNode(' ', mkNode('e', mkLeaf('S'), mkNode('i', NULL, mkLeaf('n'))), mkNode('e', mkNode('o', NULL, mkLeaf('d')), mkNode('r', NULL, mkLeaf(' ')))), mkNode(' ', mkNode('c', mkLeaf('i'), mkNode('h', NULL, mkLeaf('t'))), mkNode('i', mkNode('s', NULL, mkLeaf('e')), mkNode('n', NULL, mkLeaf(','))))), mkNode('e', mkNode('i', mkNode('a', mkLeaf('d'), mkNode('s', NULL, mkLeaf(' '))), mkNode(' ', mkNode('s', NULL, mkLeaf('t')), mkNode('h', NULL, mkLeaf('i')))), mkNode(' ', mkNode('d', mkNode('r', NULL, mkLeaf(' ')), mkNode('i', NULL, mkLeaf('e'))), mkNode('a', mkNode('F', NULL, mkLeaf('r')), mkNode('g', NULL, mkLeaf('e'))))));

  char input;
  printf("Zeichen eingeben: ");
  scanf("%c", &input);
  printf("Das Zeichen '%c' kommt %d mal vor\n", input, count_occurrences(tree, input));

  print_inorder(tree);
  return 1;
}
\end{lstlisting}
\end{document}