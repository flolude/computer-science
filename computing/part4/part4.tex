\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage[a4paper, total={6in, 10in}]{geometry}

\title{Rechnerstrukturen: Übungsblatt 4}
\author{Florian Ludewig (185722)}
\date\today

\definecolor{my_red}{RGB}{216,60,104}
\definecolor{my_green}{RGB}{68,189,77}
\definecolor{my_grey}{RGB}{78,90,107}
\lstdefinestyle{customCStyle}{
  language=C,
  numbers=left,
  stepnumber=1,
  breaklines=true,
  showstringspaces=false,
  keywordstyle=\color{my_red},
  stringstyle=\color{my_green},
  commentstyle=\color{my_grey},
  morecomment=[l][\color{magenta}]
}
\lstset{basicstyle=\ttfamily\small,style=customCStyle}

\begin{document}
\maketitle

\section*{Aufgabe 3}
\begin{lstlisting}
int odd_ones(unsigned x)
{
  for (int i = 16; i >= 1; i /= 2)
  {
    int shifted = x >> i;
    x = x ^ shifted;
  }
  return x << 31 >> 31;
}
\end{lstlisting}

Die Anfangs 32-stellige Bitsequencz wird jede Iteration der Schleife in zwei gleich
große Abschnitte geteilt. Diese Abschnitte werden dann mit einem bitweisen \texttt{XOR} verglichen.
Wenn \texttt{x} ursprünglich eine ungerade Anzahl an Einsen hatte, hat auch das neue Zwischenergebnis,
welches nur noch halb so groß ist, wieder eine ungerade Anzahl an Einsen (gilt ebenfalls
für gerade Anzahl an Einsen). In der letzten Iteration ist somit das einzige Bit welches
übrig bleibt entweder \texttt{1} (ungerade Anzahl an Einsen) oder \texttt{0} (gerade Anzahl an Einsen).

\vspace*{2\baselineskip}
\emph{Aufgabe 4 auf Seite 2}

\pagebreak
\section*{Aufgabe 4}
\begin{lstlisting}
#include <stdio.h>

unsigned short compare(unsigned short x, unsigned short mask)
{
  return (x & mask) == mask;
}

int rows(unsigned short x)
{
  int top = 0b0000000111000000;
  int middle = 0b0000000000111000;
  int bottom = 0b0000000000000111;

  return (compare(x, top) || compare(x, middle) || compare(x, bottom));
}

int columns(unsigned short x)
{
  int left = 0b0000000001001001;
  int middle = 0b0000000010010010;
  int right = 0b0000000100100100;

  return (compare(x, left) || compare(x, middle) || compare(x, right));
}

int diagonals(unsigned short x)
{
  int bottom_left_to_top_right = 0b0000000100010001;
  int bottom_right_to_top_left = 0b0000000100010100;

  return (compare(x, bottom_left_to_top_right) || compare(x, bottom_right_to_top_left));
}

unsigned short winner_result(unsigned short x)
{
  int one_is_winner = (columns(x) || diagonals(x) || rows(x));
  int zero_is_winner = (columns(~x) || diagonals(~x) || rows(~x));
  if (one_is_winner && zero_is_winner)
    return (x & 0b0111111111111111);
  if (one_is_winner || zero_is_winner)
    return (x | 0b1000000000000000);
  return (x & 0b0111111111111111);
}
\end{lstlisting}
Die Funktion \texttt{winner\_result} ist die Funktion die das nach Aufgabenstellung gewünschte Resultat zurückgibt.

\end{document}